#!/home/ayusman/bin/anaconda3/bin/python
# encoding: utf-8
"""Command line interface for PyAR"""
import argparse
import datetime
import filecmp
import logging
import os
import sys
import time
from collections import defaultdict
from itertools import permutations

from pyar import reactor, aggregator, scan, Molecule
from pyar.data import defualt_parameters, atomic_data
from pyar.property import get_atomic_number

global mol


def common_arguments(parser):
    parser.add_argument('-v', '--verbosity',
                        choices=[0, 1, 2, 3, 4],
                        type=int,
                        default=1,
                        help="Choose output verbosity"
                             " (0=Debug; 1 = Info (default); "
                             "2 = Warning; 3 = Error; 4 = Critical)")
    parser.add_argument("input_files", metavar='file',
                        type=str, nargs='+',
                        help='input coordinate files in xyz format.')


def quantum_chemistry_arguments(parser):
    quantum_chemistry_group = parser.add_argument_group('calculation',
                                                        'Calculation specific options')
    quantum_chemistry_group.add_argument("--software", type=str,
                                         choices=['gaussian', 'mopac', 'obabel', 'orca',
                                                  'psi4', 'turbomole', 'xtb',
                                                  'xtb_turbo'],
                                         required=True, help="Software")
    quantum_chemistry_group.add_argument('-basis', '--basis', type=str,
                                         help='Basis set (default=def2-SVP)')
    quantum_chemistry_group.add_argument('-method', '--method', type=str,
                                         help='The method (default=BP86)')
    quantum_chemistry_group.add_argument('--opt-threshold', type=str, default='normal',
                                         choices=['loose', 'normal', 'tight'],
                                         help='Optimization threshold')
    quantum_chemistry_group.add_argument('--opt-cycles', type=int, default=100,
                                         help='Maximum optimization cycles')
    quantum_chemistry_group.add_argument('--scf-threshold', type=str, default='normal',
                                         choices=['loose', 'normal', 'tight'],
                                         help='SCF threshold')
    quantum_chemistry_group.add_argument('--scf-cycles', type=int, default=1000,
                                         help='Maximum SCF cycles.')
    quantum_chemistry_group.add_argument('--custom-keywords', type=str,
                                         help='Software related custom keywords.')


def molecule_arguments(parser):
    molecule_group = parser.add_argument_group('molecule',
                                               'Options related to the electronic'
                                               ' structure of the molecule')
    molecule_group.add_argument("-c", "--charge", type=int, nargs='+',
                                metavar='c',
                                help="Charge of the system")
    molecule_group.add_argument("-m", "--multiplicity", type=int, nargs='+',
                                metavar='m',
                                help="Multiplicity of the system")
    molecule_group.add_argument("--scftype", type=str, nargs='+',
                                help="specify rhf or uhf (default=rhf)")


def reactor_arguments(parser):
    reactor_group = parser.add_argument_group('reactor',
                                              'Reactor specific option')
    reactor_group.add_argument('-gmin', type=float,
                               help='minimum value of gamma')
    reactor_group.add_argument('-gmax', type=float,
                               help='maximum value of gamma')
    reactor_group.add_argument('--site', type=int, nargs=2,
                               help='atom for site specific reaction')


def aggregator_arguments(parser):
    aggregator_group = parser.add_argument_group('aggregator',
                                                 'Aggregator specific options')
    aggregator_group.add_argument('-ss', '--solvation-size', type=int, metavar='n',
                                  help='number of solvent molecules to be added')
    aggregator_group.add_argument('-mns', '--maximum-number-of-seeds', metavar='n',
                                  type=int,
                                  help='maximum number of seeds')
    aggregator_group.add_argument('-as', '--aggregate-size', type=int, nargs='*',
                                  metavar=('l', 'm',),
                                  help='number of monomers in aggregate')

    aggregator_group.add_argument('--number-of-pathways', type=int, metavar='n',
                                  help='How many pathways to be used in '
                                       'binary/ternary aggregation.')


def run_type_arguments(parser):
    run_type_group = parser.add_mutually_exclusive_group(required=True)
    run_type_group.add_argument("-r", "--react",
                                help="Run a reactor calculation",
                                action='store_true')
    run_type_group.add_argument("-s", "--solvate",
                                help="Add one solvent molecules to given solute molecules",
                                action='store_true')
    run_type_group.add_argument("-a", "--aggregate",
                                help="Run a aggregator calculation",
                                action='store_true')
    run_type_group.add_argument("--scan-bond", nargs=2, type=int, metavar=('a', 'b'),
                                help="scan a bond between the given atoms of two"
                                     "fragments")


def tabu_arguments(parser):
    parser.add_argument('-N', dest='how_many_orientations', metavar='N',
                        required=True, help='The number of orientations to be used')
    parser.add_argument('--tabu', choices=['y', 'n'], default='y',
                        help='Toggle Tabu search algorithm. Default is on (y)')
    parser.add_argument('--grid', choices=['y', 'n'], default='y',
                        help='Toggle the use of grid for search space.')


def queue_arguments(parser):
    parser.add_argument('-nprocs', '--nprocs', metavar='n',
                        type=int, help='The number of processors/cores to be '
                                       'used by the quantum chemistry software.'
                                       'Not fully implemented with all interfaces.'
                                       'Write to anoop@chem.iitkgp.ac.in if this '
                                       'does not work properly')


def argument_parse() -> object:
    """ Parse command line arguments
    :return: argparse object
    :rtype: Namespace
    """

    pyr_description = """PyAR is a program to predict aggregation, reaction, 
    and clustering. Reactor explores several possible reactions between two 
    given molecules. Aggregator module explores several possible geometries 
    of weakly bound molecular complexes or atomic clusters.
    """

    parser = argparse.ArgumentParser(prog='PyAR', description=pyr_description)

    queue_arguments(parser)
    common_arguments(parser)
    tabu_arguments(parser)
    run_type_arguments(parser)
    aggregator_arguments(parser)
    reactor_arguments(parser)
    molecule_arguments(parser)
    quantum_chemistry_arguments(parser)

    return parser.parse_args()


# noinspection PyTypeChecker
def check_for_duplicate_file_arguments(error_logger, input_file_arguments):
    for a, b in permutations(input_file_arguments, 2):
        if os.path.exists(a) and os.path.exists(b) and filecmp.cmp(a, b):
            same_file_error = f'You have provided same file {a} twice.\n' \
                              f'If you want to create a homo-elemental clusters, ' \
                              f'provide file name only once.'
            error_logger.error(same_file_error)
            sys.exit(same_file_error)


def process_file_args(input_file_arguments, charges, multiplicities, scftypes, info_logger, error_logger):
    input_molecules = []
    # noinspection PyTypeChecker
    for each_file, charge, multiplicity, scftype in \
            zip(input_file_arguments, charges, multiplicities, scftypes):
        if os.path.splitext(each_file)[-1] == '.xyz':
            mol = Molecule.Molecule.from_xyz(each_file)
        elif each_file.capitalize() in atomic_data.chemical_symbols:
            mol = Molecule.Molecule.from_symbol(each_file.capitalize())
        else:
            message = f'Check input files'
            error_logger.critical(message)
            sys.exit(message)
        mol.charge = charge
        mol.multiplicity = multiplicity
        mol.atomic_number = get_atomic_number(mol.atoms_list)
        n_electrons = sum(mol.atomic_number) - mol.charge

        check_charge_multiplicity_and_scftype(n_electrons, multiplicity, error_logger)
        input_molecules.append(mol)
        info_logger.info(f" {each_file} {charge} {multiplicity} {scftype}")
    return input_molecules


def check_charge_multiplicity_and_scftype(n_electrons, multiplicity, error_logger):
    incorrect = False
    if n_electrons % 2 == 0:
        if multiplicity % 2 != 1:
            incorrect = True
    else:
        ground_scftype = 'open'
        if multiplicity % 2 == 1:
            incorrect = True
    if incorrect:
        message = f"{n_electrons} (even) electrons and " \
                  f"multiplicity {multiplicity} (odd) " \
                  f"is not possible"
        error_logger.critical(message)
        sys.exit(message)


def process_scftype_input(number_of_input_files, info_logger, scftypes):
    if scftypes is None:
        scftypes = ['rhf' for _ in range(number_of_input_files)]
    if len(scftypes) != number_of_input_files:
        message = f"SCF Types are not specified for all input files"
        info_logger.critical(message)
        sys.exit(message)
    info_logger.debug(f"Provided SCF types: {scftypes}")
    return scftypes


def process_multiplicity_input(multiplicities, number_of_input_files, info_logger, error_logger):
    if multiplicities is None:
        multiplicities = [1 for _ in range(number_of_input_files)]
    number_of_multiplicity_arguments = len(multiplicities)
    info_logger.debug(f"Provided {number_of_multiplicity_arguments} multiplicities")
    if number_of_multiplicity_arguments != number_of_input_files:
        message = f"Multiplicities are not specified for all input files"
        error_logger.critical(message)
        sys.exit(message)
    return multiplicities


def process_charge_input(charges, error_logger, info_logger, number_of_input_files):
    if charges is None:
        charges = [0 for _ in range(number_of_input_files)]
    number_of_charge_arguments = len(charges)
    info_logger.debug(f"{number_of_charge_arguments} charge arguments")
    if number_of_charge_arguments != number_of_input_files:
        message = f"Charges are not specified for all input files"
        error_logger.critical(message)
        sys.exit(message)
    return charges


def setup_logging(verbosity):
    logger = logging.getLogger('pyar')
    handler = logging.FileHandler('pyar.log', 'w')
    if verbosity == 0:
        logger.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(name)-12s %(filename)s %(funcName)s '
                                      '%(lineno)d %(levelname)-8s: %(message)s')
    elif verbosity == 1:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.INFO)
    elif verbosity == 2:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.WARNING)
    elif verbosity == 3:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.ERROR)
    elif verbosity == 4:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.CRITICAL)
    else:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.CRITICAL)
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    error_logger = logging.getLogger('pyar_errors')
    error_handler = logging.FileHandler('error.log', 'w')
    error_formatter = logging.Formatter('%(message)s')
    error_logger.setLevel(logging.CRITICAL)
    error_handler.setFormatter(error_formatter)
    error_logger.addHandler(error_handler)
    return error_logger, logger


def main():
    """
    Process the parameters, setups the jobs and executes.
    """

    args = vars(argument_parse())

    run_parameters = defaultdict(lambda: None, defualt_parameters.values)

    for key, value in args.items():
        if args[key] is not None and run_parameters[key] != args[key]:
            run_parameters[key] = args[key]

    verbosity: int = run_parameters['verbosity']
    error_logger, info_logger = setup_logging(verbosity)

    time_now = datetime.datetime.now().strftime("%d %b %Y, %H:%M:%S")
    info_logger.info(f'============ Starting PyAR at {time_now} ================')
    info_logger.info(f'Job directory: {os.getcwd()}')
    info_logger.debug(f'Logging level is {{{info_logger.level}}}')

    info_logger.debug(f'Parsed arguments are:')

    for k, v in args.items():
        if v:
            info_logger.debug(f"{k:25} = {v}")

    info_logger.debug(f'Full parameters are:')
    for k, v in run_parameters.items():
        if v:
            info_logger.debug(f"{k:25} = {v}")

    tabu_on = run_parameters['tabu'] == 'y'
    grid_on = run_parameters['grid'] == 'y'
    # Sanity check
    number_of_input_files = len(run_parameters['input_files'])
    info_logger.debug(f"{number_of_input_files} input files")

    charges = run_parameters['charge']
    charges = process_charge_input(charges, error_logger, info_logger, number_of_input_files)

    multiplicities = run_parameters['multiplicity']
    multiplicities = process_multiplicity_input(multiplicities, number_of_input_files, info_logger, error_logger)

    scftypes = run_parameters['scftype']
    scftypes = process_scftype_input(number_of_input_files, info_logger, scftypes)

    info_logger.info("Parsing the following files: ")
    input_file_arguments = run_parameters['input_files']
    input_molecules = process_file_args(input_file_arguments, charges, multiplicities, scftypes, info_logger,
                                        error_logger)

    quantum_chemistry_parameters = {
        'basis': run_parameters['basis'],
        'method': run_parameters['method'],
        'software': run_parameters['software'],
        'opt_cycles': run_parameters['opt_cycles'],
        'opt_threshold': run_parameters['opt_threshold'],
        'scf_cycles': run_parameters['scf_cycles'],
        'scf_threshold': run_parameters['scf_threshold'],
        'nprocs': run_parameters['nprocs'],
        'gamma': run_parameters['gamma'],
        'custom_keyword': run_parameters['custom_keyword']
    }

    info_logger.info(f'QM Software:   {quantum_chemistry_parameters["software"]}')

    number_of_orientations = run_parameters['how_many_orientations']
    info_logger.info(f'Number of orientations: {number_of_orientations}')

    maximum_number_of_seeds = run_parameters['maximum_number_of_seeds']
    info_logger.info(f'Maximum number of seeds: {maximum_number_of_seeds}')

    if run_parameters['site'] is None:
        site = None
    else:
        site = run_parameters['site']
        # noinspection PyUnresolvedReferences
        site = [site[0], input_molecules[0].number_of_atoms + site[1]]

    if run_parameters['aggregate']:
        size_of_aggregate = run_parameters['aggregate_size']
        if size_of_aggregate is None or len(size_of_aggregate) != len(input_molecules):
            message = f"Error: For an Aggregation run, specify \n" \
                      f"the desired number of each monomers to be added \n" \
                      f"using the argument\n" \
                      f" -as <int> <int> ..."
            info_logger.critical(message)
            sys.exit(message)
        if number_of_input_files > 1:
            check_for_duplicate_file_arguments(error_logger, input_file_arguments)
        seeds = input_molecules
        t1_0 = time.time()
        time_started = datetime.datetime.now()
        aggregator.aggregate(seeds, size_of_aggregate,
                             number_of_orientations,
                             quantum_chemistry_parameters,
                             maximum_number_of_seeds,
                             run_parameters['first_pathway'],
                             run_parameters['number_of_pathways'],
                             tabu_on, grid_on, site)

        info_logger.info('Total Time: {}'.format(time.time() - t1_0))
        info_logger.info("Started at {}\nEnded at {}".format(time_started, datetime.datetime.now()))

    if run_parameters['solvate']:
        number_of_solvent_molecules = run_parameters['solvation_size']
        if number_of_solvent_molecules is None:
            message = f'For this please provide the number of solvent\n' \
                      f'molecules to be added. Use the following option\n' \
                      f'  -ss <int>'

            error_logger.error(message)
            sys.exit(message)

        if len(input_molecules) == 1:
            message = f"Please provide more than two molecules.\n" \
                      f"The last input file will be considered as solvent\n" \
                      f"and the other molecules as solutes to which solvent\n" \
                      f"molecules will be added."
            error_logger.error(message)
            sys.exit(message)
        else:
            monomer = input_molecules[-1]
            seeds = input_molecules[:-1]

        t1_0 = time.time()
        time_started = datetime.datetime.now()
        aggregator.solvate(seeds, monomer,
                           number_of_solvent_molecules,
                           number_of_orientations,
                           quantum_chemistry_parameters,
                           maximum_number_of_seeds,
                           tabu_on,
                           grid_on,
                           site)

        info_logger.info('Total Time: {}'.format(time.time() - t1_0))
        info_logger.info("Started at {}\nEnded at {}".format(time_started, datetime.datetime.now()))

    if run_parameters['react']:
        minimum_gamma = run_parameters['gmin']
        maximum_gamma = run_parameters['gmax']
        if len(input_molecules) == 1:
            message = f'Reactor requires at least two molecules' \
                      f'Missing arguments: -r molecule_1.xyz molecule_2.xyz'
            error_logger.error(message)
            sys.exit(message)
        if minimum_gamma is None or maximum_gamma is None:
            error_logger.error('For a Reactor run specify the '
                               'values of gamma_min and gamma_max using \n'
                               '-gmin <integer> -gmax <integer>')
            sys.exit('missing arguments: -gmin <integer> -gmax <integer>')
        if number_of_orientations is None:
            error_logger.error("For reaction, specify how many orientations"
                               "are to be used, by the argument\n"
                               "-number_of_orientations <number of orientations>")
            sys.exit('Missing arguments: -N #')

        proximity_factor = 2.3

        zero_time = time.time()
        time_started = datetime.datetime.now()
        if quantum_chemistry_parameters['software'] not in ['turbomole', 'xtb_turbo']:
            message = f'reactor runs only with turbomole or xtb_turbo'
            error_logger.critical(message)
            sys.exit(message)
        # noinspection PyTypeChecker
        reactor.react(input_molecules[0], input_molecules[1],
                      minimum_gamma, maximum_gamma,
                      int(number_of_orientations),
                      quantum_chemistry_parameters,
                      site, proximity_factor, tabu_on, grid_on)
        info_logger.info('Total run time: {}'.format(time.time() - zero_time))
        info_logger.info(f"Started at {time_started}\nEnded at {datetime.datetime.now()}")
        return

    if run_parameters['scan_bond']:
        if number_of_orientations is None:
            error_logger.error("For aggregation, specify how many orientations"
                               "are    to be used, by the argument\n"
                               "-N <number of orientations>")
            sys.exit('Missing arguments: -N #')

        # noinspection PyTypeChecker
        number_of_orientations = int(number_of_orientations)
        site_atoms = run_parameters['scan_bond']

        scan.scan_distance(input_molecules, site_atoms, number_of_orientations, quantum_chemistry_parameters)

    return


if __name__ == "__main__":
    main()
